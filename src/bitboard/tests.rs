use super::{*, axis::*, direction::*};

//=======================================
// Tests for bit shift on struct BitBoard
//=======================================

// #region Tests bitshift
#[test]
fn test_bitshift_left_by_4_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let expected = BitBoard::from_array([
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000101,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000
    ]);

    // Act
    let result = original.shift_left(4);

    // Assert
    assert_eq!(expected.b, result.b);
}

#[test]
fn test_bitshift_left_by_128_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let expected = BitBoard::from_array([
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    ]);

    // Act
    let result = original.shift_left(128);

    // Assert
    assert_eq!(expected.b, result.b);
}

#[test]
fn test_bitshift_left_by_0_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);

    // Act
    let result = original.shift_left(0);

    // Assert
    assert_eq!(original.b, result.b);
}

#[test]
fn test_bitshift_left_by_max_minus_1_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let expected = BitBoard::from_array([
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    ]);
    let by = (BITS_IN_U128 * 3) - 1;

    // Act
    let result = original.shift_left(by);

    // Assert
    assert_eq!(expected.b, result.b);
}

#[test]
fn test_bitshift_left_by_max_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let expected = BitBoard::default();
    let by = BITS_IN_U128 * 3;

    // Act
    let result = original.shift_left(by);

    // Assert
    assert_eq!(expected.b, result.b);
}

// The following test perform no assertion because we just want to verify
// that no panic occurs regardeless the value passed to the function.
#[test]
fn test_bitshift_left_by_any_value() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);

    // Act
    for x in 0..(size_of::<u128>() * 3) {
        original.shift_left(x);
    }

    // No assert
}

#[test]
fn test_bitshift_right_by_4_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011010,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010011
    ]);
    let expected = BitBoard::from_array([
        0b00001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b00010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
        0b10100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);

    // Act
    let result = original.shift_right(4);

    // Assert
    assert_eq!(expected.b, result.b);
}

#[test]
fn test_bitshift_right_by_128_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let expected = BitBoard::from_array([
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    ]);

    // Act
    let result = original.shift_right(128);

    // Assert
    assert_eq!(expected.b, result.b);
}

#[test]
fn test_bitshift_right_by_0_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);

    // Act
    let result = original.shift_right(0);

    // Assert
    assert_eq!(original.b, result.b);
}

#[test]
fn test_bitshift_right_by_max_minus_1_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let expected = BitBoard::from_array([
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let by = (BITS_IN_U128 * 3) - 1;

    // Act
    let result = original.shift_right(by);

    // Assert
    assert_eq!(expected.b, result.b);
}

#[test]
fn test_bitshift_right_by_max_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let expected = BitBoard::default();
    let by = BITS_IN_U128 * 3;

    // Act
    let result = original.shift_right(by);

    // Assert
    assert_eq!(expected.b, result.b);
}

// The following test perform no assertion because we just want to verify
// that no panic occurs regardeless the value passed to the function.
#[test]
fn test_bitshift_right_by_any_value() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);

    // Act
    for x in 0..(size_of::<u128>() * 3) {
        original.shift_right(x);
    }

    // No assert
}
// #endregion Tests bitshift

//==============================
// Tests for struct AxisIterator
//==============================

// #region Tests AxisIterator
#[test]
fn test_iterate_on_axis_iterator() {
    // Arrange
    let axises = AxisIterator::new();
    let expect = vec![Direction::W, Direction::N, Direction::NW, Direction::NE];

    // Act
    let result: Vec<Direction> = axises.collect();

    // Assert
    assert_eq!(expect, result);
}
// #endregion Tests AxisIterator

//===================================
// Tests for struct DirectionIterator
//===================================

// #region Tests DirectionIterator
#[test]
fn test_iterate_on_direction_iterator() {
    // Arrange
    let directions = DirectionIterator::new();
    let expect = vec![Direction::N, Direction::S, Direction::E, Direction::W, Direction::NE, Direction::NW, Direction::SE, Direction::SW];

    // Act
    let result: Vec<Direction> = directions.collect();

    // Assert
    assert_eq!(expect, result);
}
// #endregion Tests DirectionIterator

//==================================================
// Test for Display trait implementation on BitBoard
//==================================================

// #region Tests Display
#[test]
fn test_display_on_a_bitboard_full() {
    // Arrange
    let bitboard = BitBoard::full();

    // Act
    println!("{}", bitboard);

    // Assert
}

#[test]
fn test_display_on_a_bitboard_empty() {
    // Arrange
    let bitboard = BitBoard::empty();

    // Act
    println!("{}", bitboard);

    // Assert
}
// #endregion Tests Display

//===============================================
// Tests for Not trait implementation on BitBoard
//===============================================

// #region Tests Not
#[test]
fn test_not_on_bitboard_full() {
    // Arrange
    let bitboard = BitBoard::full();
    let expected = BitBoard::empty();

    // Act
    let result = !bitboard;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_not_on_bitboard_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let expected = BitBoard::full();

    // Act
    let result = !bitboard;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_not_on_bitboard_with_some_bits_set() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000001110000000000000000000000000000000000000000000000000000001000000000000000000,
        0b01011000000000000000001000000000000000000000000000000000000000000000000000000000000000000010000000000000000001100010000000000000,
        0b10000000000000000000000001000000000000000000000000000000000000000000001100000000000000000000000000000000010000000010000000000001
    ]);
    let expected = BitBoard::from_array([
        0b00110111111111111111111111111111111111111111111111110001111111111111111111111111111111111111111111111111111110111111111111111111,
        0b10100111111111111111110111111111111111111111111111111111111111111111111111111111111111111101111111111111111110011101111111111111,
        0b01111111111111111111111110111111111111111111111111111111111111111111110011111111111111111111111111111111101111111101111111111110
    ]);

    // Act
    let result = !bitboard;

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests Not

//=================================================
// Tests for BitOr trait implementation on BitBoard
//=================================================

// #region Tests BitOr
#[test]
fn test_bitor_on_bitboard_empty_with_full() {
    // Arrange
    let bitboard = BitBoard::empty();
    let or_with = BitBoard::full();
    let expected = BitBoard::full();

    // Act
    let result = bitboard | or_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitor_on_bitboard_empty_with_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let or_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    let result = bitboard | or_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitor_on_bitboard_full_with_empty() {
    // Arrange
    let bitboard = BitBoard::full();
    let or_with = BitBoard::empty();
    let expected = BitBoard::full();

    // Act
    let result = bitboard | or_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitor_on_bitboard_even_bits_set_with_odd_bits_set() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let or_with = BitBoard::from_array([
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
    ]);
    let expected = BitBoard::full();

    // Act
    let result = bitboard | or_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitor_on_bitboard_partially_set_with_same() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let or_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = bitboard;

    // Act
    let result = bitboard | or_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitor_on_ref_bitboard_even_bits_set_with_on_odd_bits_set() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let or_with = BitBoard::from_array([
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
    ]);
    let expected = BitBoard::full();

    // Act
    let result = &bitboard | &or_with;

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests BitOr

//==================================================
// Tests for BitXor trait implementation on BitBoard
//==================================================

// #region Tests BitXor
#[test]
fn test_bitxor_on_bitboard_empty_with_full() {
    // Arrange
    let bitboard = BitBoard::empty();
    let xor_with = BitBoard::full();
    let expected = BitBoard::full();

    // Act
    let result = bitboard ^ xor_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitxor_on_bitboard_empty_with_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let xor_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    let result = bitboard ^ xor_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitxor_on_bitboard_full_with_empty() {
    // Arrange
    let bitboard = BitBoard::full();
    let xor_with = BitBoard::empty();
    let expected = BitBoard::full();

    // Act
    let result = bitboard ^ xor_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitxor_on_bitboard_even_bits_set_with_odd_bits_set() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let xor_with = BitBoard::from_array([
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
    ]);
    let expected = BitBoard::full();

    // Act
    let result = bitboard ^ xor_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitxor_on_bitboard_partially_set_with_same() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let xor_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = BitBoard::empty();

    // Act
    let result = bitboard ^ xor_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitxor_on_ref_bitboard_partially_set_with_same() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let xor_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = BitBoard::empty();

    // Act
    let result = &bitboard ^ &xor_with;

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests BitXor

//==================================================
// Tests for BitAnd trait implementation on BitBoard
//==================================================

// #region Tests BitAnd
#[test]
fn test_bitand_on_bitboard_empty_with_full() {
    // Arrange
    let bitboard = BitBoard::empty();
    let and_with = BitBoard::full();
    let expected = BitBoard::empty();

    // Act
    let result = bitboard & and_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitand_on_bitboard_empty_with_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let and_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    let result = bitboard & and_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitand_on_bitboard_full_with_empty() {
    // Arrange
    let bitboard = BitBoard::full();
    let and_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    let result = bitboard & and_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitand_on_bitboard_even_bits_set_with_odd_bits_set() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let and_with = BitBoard::from_array([
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
    ]);
    let expected = BitBoard::empty();

    // Act
    let result = bitboard & and_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitand_on_bitboard_partially_set_with_same() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let and_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = bitboard;

    // Act
    let result = bitboard & and_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitand_on_ref_bitboard_partially_set_with_same() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let and_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = bitboard;

    // Act
    let result = &bitboard & &and_with;

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests BitAnd

//=======================================================
// Tests for BitOrAssign trait implementation on BitBoard
//=======================================================

// #region Tests BitOrAssign
#[test]
fn test_bitorassign_on_bitboard_empty_with_full() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let or_with = BitBoard::full();
    let expected = BitBoard::full();

    // Act
    bitboard |= or_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitorassign_on_bitboard_empty_with_empty() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let or_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    bitboard |= or_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitorassign_on_bitboard_full_with_empty() {
    // Arrange
    let mut bitboard = BitBoard::full();
    let or_with = BitBoard::empty();
    let expected = BitBoard::full();

    // Act
    bitboard |= or_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitorassign_on_bitboard_even_bits_set_with_odd_bits_set() {
    // Arrange
    let mut bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let or_with = BitBoard::from_array([
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
    ]);
    let expected = BitBoard::full();

    // Act
    bitboard |= or_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitorassign_on_bitboard_partially_set_with_same() {
    // Arrange
    let mut bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let or_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = bitboard;

    // Act
    bitboard |= or_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitorassign_on_ref_bitboard_even_bits_set_with_on_odd_bits_set() {
    // Arrange
    let mut bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let or_with = BitBoard::from_array([
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
    ]);
    let expected = BitBoard::full();

    // Act
    bitboard |= &or_with;

    // Assert
    assert_eq!(expected, bitboard);
}
// #endregion Tests BitOrAssign

//========================================================
// Tests for BitXorAssign trait implementation on BitBoard
//========================================================

// #region Tests BitXorAssign
#[test]
fn test_bitxorassign_on_bitboard_empty_with_full() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let xor_with = BitBoard::full();
    let expected = BitBoard::full();

    // Act
    bitboard ^= xor_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitxorassign_on_bitboard_empty_with_empty() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let xor_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    bitboard ^= xor_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitxorassign_on_bitboard_full_with_empty() {
    // Arrange
    let mut bitboard = BitBoard::full();
    let xor_with = BitBoard::empty();
    let expected = BitBoard::full();

    // Act
    bitboard ^= xor_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitxorassign_on_bitboard_even_bits_set_with_odd_bits_set() {
    // Arrange
    let mut bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let xor_with = BitBoard::from_array([
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
    ]);
    let expected = BitBoard::full();

    // Act
    bitboard ^= xor_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitxorassign_on_bitboard_partially_set_with_same() {
    // Arrange
    let mut bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let xor_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = BitBoard::empty();

    // Act
    bitboard ^= xor_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitxorassign_on_ref_bitboard_even_bits_set_with_on_odd_bits_set() {
    // Arrange
    let mut bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let xor_with = BitBoard::from_array([
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
    ]);
    let expected = BitBoard::full();

    // Act
    bitboard ^= &xor_with;

    // Assert
    assert_eq!(expected, bitboard);
}
// #endregion Tests BitXorAssign

//========================================================
// Tests for BitAndAssign trait implementation on BitBoard
//========================================================

// #region Tests BitAndAssign
#[test]
fn test_bitandassign_on_bitboard_empty_with_full() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let and_with = BitBoard::full();
    let expected = BitBoard::empty();

    // Act
    bitboard &= and_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitandassign_on_bitboard_empty_with_empty() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let and_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    bitboard &= and_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitandassign_on_bitboard_full_with_empty() {
    // Arrange
    let mut bitboard = BitBoard::full();
    let and_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    bitboard &= and_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitandassign_on_bitboard_even_bits_set_with_odd_bits_set() {
    // Arrange
    let mut bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let and_with = BitBoard::from_array([
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
    ]);
    let expected = BitBoard::empty();

    // Act
    bitboard &= and_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitandassign_on_bitboard_partially_set_with_same() {
    // Arrange
    let mut bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let and_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = bitboard;

    // Act
    bitboard &= and_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitandassign_on_ref_bitboard_even_bits_set_with_on_odd_bits_set() {
    // Arrange
    let mut bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let and_with = BitBoard::from_array([
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
    ]);
    let expected = BitBoard::empty();

    // Act
    bitboard &= &and_with;

    // Assert
    assert_eq!(expected, bitboard);
}
// #endregion Tests BitAndAssign

//========================================================
// Tests for Eq/PartialEq trait implementation on BitBoard
//========================================================

// #region Tests Eq/PartialEq
#[test]
fn test_equality_on_bitboard_with_full() {
    // Arrange
    let bitboard = BitBoard::full();
    let eq_with = BitBoard::full();
    let expected = true;

    // Act
    let result = bitboard == eq_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_equality_on_bitboard_with_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let eq_with = BitBoard::empty();
    let expected = true;

    // Act
    let result = bitboard == eq_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_equality_on_bitboard_some_bits_set_with_one_bit_missing() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let eq_with = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101000101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let expected = false;

    // Act
    let result = bitboard == eq_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_equality_on_bitboard_some_bits_set() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let eq_with = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let expected = true;

    // Act
    let result = bitboard == eq_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_unequality_on_bitboard_with_full() {
    // Arrange
    let bitboard = BitBoard::full();
    let eq_with = BitBoard::full();
    let expected = false;

    // Act
    let result = bitboard != eq_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_unequality_on_bitboard_with_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let eq_with = BitBoard::empty();
    let expected = false;

    // Act
    let result = bitboard != eq_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_unequality_on_bitboard_some_bits_set_with_one_bit_missing() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let eq_with = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101000101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let expected = true;

    // Act
    let result = bitboard != eq_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_unequality_on_bitboard_some_bits_set() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let eq_with = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let expected = false;

    // Act
    let result = bitboard != eq_with;

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests Eq/PartialEq

//=====================================
// Tests for is_full method on BitBoard
//=====================================

// #region Tests is_full
#[test]
fn test_method_is_full_on_bitboard_half_empty() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let expected = false;

    // Act
    let result = bitboard.is_full();

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_method_is_full_on_bitboard_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let expected = false;

    // Act
    let result = bitboard.is_full();

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_method_is_full_on_bitboard_all_bits_set_except_one() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111,
            0b01111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111,
            0b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
        ]
    };
    let expected = false;

    // Act
    let result = bitboard.is_full();

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_method_is_full_on_bitboard_full() {
    // Arrange
    let bitboard = BitBoard::full();
    let expected = true;

    // Act
    let result = bitboard.is_full();

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests is_full

//======================================
// Tests for is_empty method on BitBoard
//======================================

// #region Tests is_empty
#[test]
fn test_method_is_empty_on_bitboard_half_empty() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let expected = false;

    // Act
    let result = bitboard.is_empty();

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_method_is_empty_on_bitboard_full() {
    // Arrange
    let bitboard = BitBoard::full();
    let expected = false;

    // Act
    let result = bitboard.is_empty();

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_method_is_empty_on_bitboard_all_bits_set_except_one() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111,
            0b01111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111,
            0b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
        ]
    };
    let expected = false;

    // Act
    let result = bitboard.is_empty();

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_method_is_empty_on_bitboard_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let expected = true;

    // Act
    let result = bitboard.is_empty();

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests is_empty

//==============================================
// Tests for constructor method full on BitBoard
//==============================================

// #region Tests constructor full
#[test]
fn test_constructor_method_full_on_bitboard() {
    // Arrange
    let expected = BitBoard {
        b: [
            0b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111,
            0b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111,
            0b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
        ]
    };

    // Act
    let result = BitBoard::full();

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests constructor full

//===============================================
// Tests for constructor method empty on BitBoard
//===============================================

// #region Tests constructor empty
#[test]
fn test_constructor_method_empty_on_bitboard() {
    // Arrange
    let expected = BitBoard {
        b: [
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
        ]
    };

    // Act
    let result = BitBoard::empty();

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests constructor empty