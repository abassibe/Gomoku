use super::{*, axis::*, direction::*};

//=======================================
// Tests for bit shift on struct BitBoard
//=======================================

// #region Tests bitshift
#[test]
fn test_bitshift_left_by_4_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let expected = BitBoard::from_array([
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000101,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000
    ]);

    // Act
    let result = original.shift_left(4);

    // Assert
    assert_eq!(expected.b, result.b);
}

#[test]
fn test_bitshift_left_by_128_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let expected = BitBoard::from_array([
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    ]);

    // Act
    let result = original.shift_left(128);

    // Assert
    assert_eq!(expected.b, result.b);
}

#[test]
fn test_bitshift_left_by_0_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);

    // Act
    let result = original.shift_left(0);

    // Assert
    assert_eq!(original.b, result.b);
}

#[test]
fn test_bitshift_left_by_max_minus_1_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let expected = BitBoard::from_array([
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    ]);
    let by = (BITS_IN_U128 * 3) - 1;

    // Act
    let result = original.shift_left(by);

    // Assert
    assert_eq!(expected.b, result.b);
}

#[test]
fn test_bitshift_left_by_max_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let expected = BitBoard::default();
    let by = BITS_IN_U128 * 3;

    // Act
    let result = original.shift_left(by);

    // Assert
    assert_eq!(expected.b, result.b);
}

// The following test perform no assertion because we just want to verify
// that no panic occurs regardeless the value passed to the function.
#[test]
fn test_bitshift_left_by_any_value() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);

    // Act
    for x in 0..(size_of::<u128>() * 3) {
        original.shift_left(x);
    }

    // No assert
}

#[test]
fn test_bitshift_right_by_4_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011010,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010011
    ]);
    let expected = BitBoard::from_array([
        0b00001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b00010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001,
        0b10100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);

    // Act
    let result = original.shift_right(4);

    // Assert
    assert_eq!(expected.b, result.b);
}

#[test]
fn test_bitshift_right_by_128_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let expected = BitBoard::from_array([
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
    ]);

    // Act
    let result = original.shift_right(128);

    // Assert
    assert_eq!(expected.b, result.b);
}

#[test]
fn test_bitshift_right_by_0_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);

    // Act
    let result = original.shift_right(0);

    // Assert
    assert_eq!(original.b, result.b);
}

#[test]
fn test_bitshift_right_by_max_minus_1_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let expected = BitBoard::from_array([
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let by = (BITS_IN_U128 * 3) - 1;

    // Act
    let result = original.shift_right(by);

    // Assert
    assert_eq!(expected.b, result.b);
}

#[test]
fn test_bitshift_right_by_max_on_bitboard() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);
    let expected = BitBoard::default();
    let by = BITS_IN_U128 * 3;

    // Act
    let result = original.shift_right(by);

    // Assert
    assert_eq!(expected.b, result.b);
}

// The following test perform no assertion because we just want to verify
// that no panic occurs regardeless the value passed to the function.
#[test]
fn test_bitshift_right_by_any_value() {
    // Arrange
    let original = BitBoard::from_array([
        0b11001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b01011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
        0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
    ]);

    // Act
    for x in 0..(size_of::<u128>() * 3) {
        original.shift_right(x);
    }

    // No assert
}
// #endregion Tests bitshift

//==============================
// Tests for struct AxisIterator
//==============================

// #region Tests AxisIterator
#[test]
fn test_iterate_on_axis_iterator() {
    // Arrange
    let axises = AxisIterator::new();
    let expect = vec![Direction::W, Direction::N, Direction::NW, Direction::NE];

    // Act
    let result: Vec<Direction> = axises.collect();

    // Assert
    assert_eq!(expect, result);
}
// #endregion Tests AxisIterator

//=============================
// Tests for trait From on Axis
//=============================

// #region Tests trait From on Axis
#[test]
fn test_into_direction_on_axis() {
    // Arrange
    let axises = [Axis::Vertical, Axis::Horizontal, Axis::DiagUpLeft, Axis::DiagUpRight];
    let expected = [Direction::N, Direction::W, Direction::NW, Direction::NE];

    // Act
    let results: [Direction; 4] = [axises[0].into(), axises[1].into(), axises[2].into(), axises[3].into()];

    // Assert
    assert_eq!(expected, results);
}
// #endregion Tests trait From on Axis

//===================================
// Tests for struct DirectionIterator
//===================================

// #region Tests DirectionIterator
#[test]
fn test_iterate_on_direction_iterator() {
    // Arrange
    let directions = DirectionIterator::new();
    let expect = vec![Direction::N, Direction::S, Direction::E, Direction::W, Direction::NE, Direction::NW, Direction::SE, Direction::SW];

    // Act
    let result: Vec<Direction> = directions.collect();

    // Assert
    assert_eq!(expect, result);
}
// #endregion Tests DirectionIterator

//==================================
// Tests for trait From on Direction
//==================================

// #region Tests trait From on Direction
#[test]
fn test_into_direction_on_direction() {
    // Arrange
    let directions = [Direction::N, Direction::W, Direction::NW, Direction::NE];
    let expected = [Axis::Vertical, Axis::Horizontal, Axis::DiagUpLeft, Axis::DiagUpRight];

    // Act
    let results: [Axis; 4] = [directions[0].into(), directions[1].into(), directions[2].into(), directions[3].into()];

    // Assert
    assert_eq!(expected, results);
}
// #endregion Tests trait From on Direction

//==================================================
// Test for Display trait implementation on BitBoard
//==================================================

// #region Tests Display
#[test]
fn test_display_on_a_bitboard_full() {
    // Arrange
    let bitboard = BitBoard::full();

    // Act
    println!("{}", bitboard);

    // Assert
}

#[test]
fn test_display_on_a_bitboard_empty() {
    // Arrange
    let bitboard = BitBoard::empty();

    // Act
    println!("{}", bitboard);

    // Assert
}
// #endregion Tests Display

//===============================================
// Tests for Not trait implementation on BitBoard
//===============================================

// #region Tests Not
#[test]
fn test_not_on_bitboard_full() {
    // Arrange
    let bitboard = BitBoard::full();
    let expected = BitBoard::empty();

    // Act
    let result = !bitboard;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_not_on_bitboard_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let expected = BitBoard::full();

    // Act
    let result = !bitboard;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_not_on_bitboard_with_some_bits_set() {
    // Arrange
    let bitboard = BitBoard::from_str("
        1100100000000000000
        0000000000000000000
        0000000000001110000
        0000000000000000000
        0000000000000000000
        0000000001000000000
        0000000001011000000
        0000000000100000000
        0000000000000000000
        0000000000000000000
        0000000000000000001
        0000000000000000011
        0010000000000000100
        0000000000000000000
        0100000000000000000
        0000000000000000000
        0000001100000000000
        0000000000000000000
        0100000000100000000
    ");
    let expected = BitBoard::from_str("
        0011011111111111111
        1111111111111111111
        1111111111110001111
        1111111111111111111
        1111111111111111111
        1111111110111111111
        1111111110100111111
        1111111111011111111
        1111111111111111111
        1111111111111111111
        1111111111111111110
        1111111111111111100
        1101111111111111011
        1111111111111111111
        1011111111111111111
        1111111111111111111
        1111110011111111111
        1111111111111111111
        1011111111011111111
    ");

    // Act
    let result = !bitboard;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_not_on_bitboard_with_some_bits_set_in_edge_delimiter() {
    // Arrange
    let bitboard = BitBoard::from_str("
        00000000000000000001
        00000000000000000000
        00000000000000000000
        00000000000000000000
        00000000000000000001
        00000000000000000000
        00000000010000000001
        00000000010000000000
        00000000111000000000
        00000000111000000000
        00000000010000000000
        00000000010000000000
        00000000000000000000
        00000000000000000000
        00000000000000000001
        00000000000000000000
        00000000000000000000
        00000000000000000001
        00000000000000000000
    ");
    let expected = BitBoard::from_str("
        11111111111111111110
        11111111111111111110
        11111111111111111110
        11111111111111111110
        11111111111111111110
        11111111111111111110
        11111111101111111110
        11111111101111111110
        11111111000111111110
        11111111000111111110
        11111111101111111110
        11111111101111111110
        11111111111111111110
        11111111111111111110
        11111111111111111110
        11111111111111111110
        11111111111111111110
        11111111111111111110
        11111111111111111110
    ");

    // Act
    let result = !bitboard;
    println!("Result:\n{}", result);

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests Not

//=================================================
// Tests for BitOr trait implementation on BitBoard
//=================================================

// #region Tests BitOr
#[test]
fn test_bitor_on_bitboard_empty_with_full() {
    // Arrange
    let bitboard = BitBoard::empty();
    let or_with = BitBoard::full();
    let expected = BitBoard::full();

    // Act
    let result = bitboard | or_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitor_on_bitboard_empty_with_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let or_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    let result = bitboard | or_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitor_on_bitboard_full_with_empty() {
    // Arrange
    let bitboard = BitBoard::full();
    let or_with = BitBoard::empty();
    let expected = BitBoard::full();

    // Act
    let result = bitboard | or_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitor_on_bitboard_even_bits_set_with_odd_bits_set() {
    // Arrange
    let bitboard = BitBoard::from_str("
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
    ");
    let or_with = BitBoard::from_str("
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
    ");
    let expected = BitBoard::full();

    // Act
    let result = bitboard | or_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitor_on_bitboard_partially_set_with_same() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let or_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = bitboard;

    // Act
    let result = bitboard | or_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitor_on_ref_bitboard_even_bits_set_with_on_odd_bits_set() {
    // Arrange
    let bitboard = BitBoard::from_str("
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
    ");
    let or_with = BitBoard::from_str("
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
    ");
    let expected = BitBoard::full();

    // Act
    let result = &bitboard | &or_with;

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests BitOr

//==================================================
// Tests for BitXor trait implementation on BitBoard
//==================================================

// #region Tests BitXor
#[test]
fn test_bitxor_on_bitboard_empty_with_full() {
    // Arrange
    let bitboard = BitBoard::empty();
    let xor_with = BitBoard::full();
    let expected = BitBoard::full();

    // Act
    let result = bitboard ^ xor_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitxor_on_bitboard_empty_with_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let xor_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    let result = bitboard ^ xor_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitxor_on_bitboard_full_with_empty() {
    // Arrange
    let bitboard = BitBoard::full();
    let xor_with = BitBoard::empty();
    let expected = BitBoard::full();

    // Act
    let result = bitboard ^ xor_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitxor_on_bitboard_even_bits_set_with_odd_bits_set() {
    // Arrange
    let bitboard = BitBoard::from_str("
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
    ");
    let xor_with = BitBoard::from_str("
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
    ");
    let expected = BitBoard::full();

    // Act
    let result = bitboard ^ xor_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitxor_on_bitboard_partially_set_with_same() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let xor_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = BitBoard::empty();

    // Act
    let result = bitboard ^ xor_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitxor_on_ref_bitboard_partially_set_with_same() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let xor_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = BitBoard::empty();

    // Act
    let result = &bitboard ^ &xor_with;

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests BitXor

//==================================================
// Tests for BitAnd trait implementation on BitBoard
//==================================================

// #region Tests BitAnd
#[test]
fn test_bitand_on_bitboard_empty_with_full() {
    // Arrange
    let bitboard = BitBoard::empty();
    let and_with = BitBoard::full();
    let expected = BitBoard::empty();

    // Act
    let result = bitboard & and_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitand_on_bitboard_empty_with_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let and_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    let result = bitboard & and_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitand_on_bitboard_full_with_empty() {
    // Arrange
    let bitboard = BitBoard::full();
    let and_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    let result = bitboard & and_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitand_on_bitboard_even_bits_set_with_odd_bits_set() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let and_with = BitBoard::from_array([
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
    ]);
    let expected = BitBoard::empty();

    // Act
    let result = bitboard & and_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitand_on_bitboard_partially_set_with_same() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let and_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = bitboard;

    // Act
    let result = bitboard & and_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_bitand_on_ref_bitboard_partially_set_with_same() {
    // Arrange
    let bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let and_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = bitboard;

    // Act
    let result = &bitboard & &and_with;

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests BitAnd

//=======================================================
// Tests for BitOrAssign trait implementation on BitBoard
//=======================================================

// #region Tests BitOrAssign
#[test]
fn test_bitorassign_on_bitboard_empty_with_full() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let or_with = BitBoard::full();
    let expected = BitBoard::full();

    // Act
    bitboard |= or_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitorassign_on_bitboard_empty_with_empty() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let or_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    bitboard |= or_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitorassign_on_bitboard_full_with_empty() {
    // Arrange
    let mut bitboard = BitBoard::full();
    let or_with = BitBoard::empty();
    let expected = BitBoard::full();

    // Act
    bitboard |= or_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitorassign_on_bitboard_even_bits_set_with_odd_bits_set() {
    // Arrange
    let mut bitboard = BitBoard::from_str("
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
    ");
    let or_with = BitBoard::from_str("
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
    ");
    let expected = BitBoard::full();

    // Act
    bitboard |= or_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitorassign_on_bitboard_partially_set_with_same() {
    // Arrange
    let mut bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let or_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = bitboard;

    // Act
    bitboard |= or_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitorassign_on_ref_bitboard_even_bits_set_with_on_odd_bits_set() {
    // Arrange
    let mut bitboard = BitBoard::from_str("
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
    ");
    let or_with = BitBoard::from_str("
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
    ");
    let expected = BitBoard::full();

    // Act
    bitboard |= &or_with;

    // Assert
    assert_eq!(expected, bitboard);
}
// #endregion Tests BitOrAssign

//========================================================
// Tests for BitXorAssign trait implementation on BitBoard
//========================================================

// #region Tests BitXorAssign
#[test]
fn test_bitxorassign_on_bitboard_empty_with_full() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let xor_with = BitBoard::full();
    let expected = BitBoard::full();

    // Act
    bitboard ^= xor_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitxorassign_on_bitboard_empty_with_empty() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let xor_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    bitboard ^= xor_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitxorassign_on_bitboard_full_with_empty() {
    // Arrange
    let mut bitboard = BitBoard::full();
    let xor_with = BitBoard::empty();
    let expected = BitBoard::full();

    // Act
    bitboard ^= xor_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitxorassign_on_bitboard_even_bits_set_with_odd_bits_set() {
    // Arrange
    let mut bitboard = BitBoard::from_str("
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
    ");
    let xor_with = BitBoard::from_str("
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
    ");
    let expected = BitBoard::full();

    // Act
    bitboard ^= xor_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitxorassign_on_bitboard_partially_set_with_same() {
    // Arrange
    let mut bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let xor_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = BitBoard::empty();

    // Act
    bitboard ^= xor_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitxorassign_on_ref_bitboard_even_bits_set_with_on_odd_bits_set() {
    // Arrange
    let mut bitboard = BitBoard::from_str("
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
    ");
    let xor_with = BitBoard::from_str("
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
        1010101010101010101
        0101010101010101010
    ");
    let expected = BitBoard::full();

    // Act
    bitboard ^= &xor_with;

    // Assert
    assert_eq!(expected, bitboard);
}
// #endregion Tests BitXorAssign

//========================================================
// Tests for BitAndAssign trait implementation on BitBoard
//========================================================

// #region Tests BitAndAssign
#[test]
fn test_bitandassign_on_bitboard_empty_with_full() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let and_with = BitBoard::full();
    let expected = BitBoard::empty();

    // Act
    bitboard &= and_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitandassign_on_bitboard_empty_with_empty() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let and_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    bitboard &= and_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitandassign_on_bitboard_full_with_empty() {
    // Arrange
    let mut bitboard = BitBoard::full();
    let and_with = BitBoard::empty();
    let expected = BitBoard::empty();

    // Act
    bitboard &= and_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitandassign_on_bitboard_even_bits_set_with_odd_bits_set() {
    // Arrange
    let mut bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let and_with = BitBoard::from_array([
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
    ]);
    let expected = BitBoard::empty();

    // Act
    bitboard &= and_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitandassign_on_bitboard_partially_set_with_same() {
    // Arrange
    let mut bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let and_with = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let expected = bitboard;

    // Act
    bitboard &= and_with;

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_bitandassign_on_ref_bitboard_even_bits_set_with_on_odd_bits_set() {
    // Arrange
    let mut bitboard = BitBoard::from_array([
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
        0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
    ]);
    let and_with = BitBoard::from_array([
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101,
        0b01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
    ]);
    let expected = BitBoard::empty();

    // Act
    bitboard &= &and_with;

    // Assert
    assert_eq!(expected, bitboard);
}
// #endregion Tests BitAndAssign

//========================================================
// Tests for Eq/PartialEq trait implementation on BitBoard
//========================================================

// #region Tests Eq/PartialEq
#[test]
fn test_equality_on_bitboard_with_full() {
    // Arrange
    let bitboard = BitBoard::full();
    let eq_with = BitBoard::full();
    let expected = true;

    // Act
    let result = bitboard == eq_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_equality_on_bitboard_with_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let eq_with = BitBoard::empty();
    let expected = true;

    // Act
    let result = bitboard == eq_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_equality_on_bitboard_some_bits_set_with_one_bit_missing() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let eq_with = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101000101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let expected = false;

    // Act
    let result = bitboard == eq_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_equality_on_bitboard_some_bits_set() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let eq_with = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let expected = true;

    // Act
    let result = bitboard == eq_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_unequality_on_bitboard_with_full() {
    // Arrange
    let bitboard = BitBoard::full();
    let eq_with = BitBoard::full();
    let expected = false;

    // Act
    let result = bitboard != eq_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_unequality_on_bitboard_with_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let eq_with = BitBoard::empty();
    let expected = false;

    // Act
    let result = bitboard != eq_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_unequality_on_bitboard_some_bits_set_with_one_bit_missing() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let eq_with = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101000101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let expected = true;

    // Act
    let result = bitboard != eq_with;

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_unequality_on_bitboard_some_bits_set() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let eq_with = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let expected = false;

    // Act
    let result = bitboard != eq_with;

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests Eq/PartialEq

//=====================================
// Tests for is_full method on BitBoard
//=====================================

// #region Tests is_full
#[test]
fn test_method_is_full_on_bitboard_half_empty() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let expected = false;

    // Act
    let result = bitboard.is_full();

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_method_is_full_on_bitboard_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let expected = false;

    // Act
    let result = bitboard.is_full();

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_method_is_full_on_bitboard_all_bits_set_except_one() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111,
            0b01111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111,
            0b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
        ]
    };
    let expected = false;

    // Act
    let result = bitboard.is_full();

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_method_is_full_on_bitboard_full() {
    // Arrange
    let bitboard = BitBoard::full();
    let expected = true;

    // Act
    let result = bitboard.is_full();
    println!("BitBoard:\n{}", bitboard);

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests is_full

//======================================
// Tests for is_empty method on BitBoard
//======================================

// #region Tests is_empty
#[test]
fn test_method_is_empty_on_bitboard_half_empty() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010,
            0b10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010
        ]
    };
    let expected = false;

    // Act
    let result = bitboard.is_empty();

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_method_is_empty_on_bitboard_full() {
    // Arrange
    let bitboard = BitBoard::full();
    let expected = false;

    // Act
    let result = bitboard.is_empty();

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_method_is_empty_on_bitboard_all_bits_set_except_one() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111,
            0b01111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111,
            0b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
        ]
    };
    let expected = false;

    // Act
    let result = bitboard.is_empty();

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_method_is_empty_on_bitboard_empty() {
    // Arrange
    let bitboard = BitBoard::empty();
    let expected = true;

    // Act
    let result = bitboard.is_empty();

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests is_empty

//==============================================
// Tests for constructor method full on BitBoard
//==============================================

// #region Tests constructor full
#[test]
fn test_constructor_method_full_on_bitboard() {
    // Arrange
    let expected = BitBoard::from_str("
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
        1111111111111111111
    ");

    // Act
    let result = BitBoard::full();

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests constructor full

//===============================================
// Tests for constructor method empty on BitBoard
//===============================================

// #region Tests constructor empty
#[test]
fn test_constructor_method_empty_on_bitboard() {
    // Arrange
    let expected = BitBoard {
        b: [
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
        ]
    };

    // Act
    let result = BitBoard::empty();

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests constructor empty

//=================================================
// Tests for Index trait implementation on BitBoard
//=================================================

// #region Tests Index
#[test]
fn test_index_on_bitboard_with_bit_set() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b00000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
        ]
    };
    let bit_index = [41, 42, 43];
    let expected = [false, true, false];

    // Act
    let results = [bitboard[bit_index[0]], bitboard[bit_index[1]], bitboard[bit_index[2]]];

    // Assert
    assert_eq!(expected, results);
}

#[test]
fn test_index_on_bitboard_with_bit_set_neg_index() {
    // Arrange
    let bitboard = BitBoard {
        b: [
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000
        ]
    };
    let bit_index = [-41, -42, -43];
    let expected = [false, true, false];

    // Act
    let results = [bitboard[bit_index[0]], bitboard[bit_index[1]], bitboard[bit_index[2]]];

    // Assert
    assert_eq!(expected, results);
}

// TODO: Add tests for Index<(usize, usize)> and Index<(u32, u32)>
// #endregion Tests Index

//=================================
// Tests for set method on BitBoard
//=================================

// #region Tests set
#[test]
fn test_method_set_on_bitboard_empty_set() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let expected = BitBoard {
        b: [
            0b00000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
        ]
    };
    let bit_index = 42;
    let bit_value = true;

    // Act
    bitboard.set(bit_index, bit_value);

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_method_set_on_bitboard_full_set() {
    // Arrange
    let mut bitboard = BitBoard::full();
    let expected = BitBoard::full();
    let bit_index = 42;
    let bit_value = true;

    // Act
    bitboard.set(bit_index, bit_value);

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_method_set_on_bitboard_empty_unset() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let expected = BitBoard::empty();
    let bit_index = 42;
    let bit_value = false;

    // Act
    bitboard.set(bit_index, bit_value);

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_method_set_on_bitboard_full_unset() {
    // Arrange
    let mut bitboard = BitBoard::full();
    let expected = BitBoard {
        b: [
            0b11111111111111111110111111111111111111101101111111111111111011111111111111111110111111111111111111101111111111111111111011111111,
            0b11111111111011111111111111111110111111111111111111101111111111111111111011111111111111111110111111111111111111101111111111111111,
            0b11101111111111111111111011111111111111111110111111111111111111101111111111111111111011111111111111111110111111111111111111100000
        ]
    };
    let bit_index = 42;
    let bit_value = false;

    // Act
    bitboard.set(bit_index, bit_value);

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_method_set_on_bitboard_empty_set_neg_index() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let expected = BitBoard {
        b: [
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000
        ]
    };
    let bit_index = -42;
    let bit_value = true;

    // Act
    bitboard.set(bit_index, bit_value);

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_method_set_on_bitboard_full_set_neg_index() {
    // Arrange
    let mut bitboard = BitBoard::full();
    let expected = BitBoard::full();
    let bit_index = -42;
    let bit_value = true;

    // Act
    bitboard.set(bit_index, bit_value);

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_method_set_on_bitboard_empty_unset_neg_index() {
    // Arrange
    let mut bitboard = BitBoard::empty();
    let expected = BitBoard::empty();
    let bit_index = -42;
    let bit_value = false;

    // Act
    bitboard.set(bit_index, bit_value);

    // Assert
    assert_eq!(expected, bitboard);
}

#[test]
fn test_method_set_on_bitboard_full_unset_neg_index() {
    // Arrange
    let mut bitboard = BitBoard::full();
    let expected = BitBoard {
        b: [
            0b11111111111111111110111111111111111111101111111111111111111011111111111111111110111111111111111111101111111111111111111011111111,
            0b11111111111011111111111111111110111111111111111111101111111111111111111011111111111111111110111111111111111111101111111111111111,
            0b11101111111111111111111011111111111111111110111111111111111111101111111111111111111011011111111111111110111111111111111111100000
        ]
    };
    let bit_index = -42;
    let bit_value = false;

    // Act
    bitboard.set(bit_index, bit_value);

    // Assert
    assert_eq!(expected, bitboard);
}
// #endregion Tests set

//======================================
// Tests for dilation method on BitBoard
//======================================

// #region Tests Dilation/Erosion
#[test]
fn test_dilation_on_bitboard_all_direction() {
    // Arrange
    // 10000000000000000002
    // 00000000000000000002
    // 00000000000000000112
    // 00000000000000000112
    // 00000000000000000002
    // 00001100000000000002
    // 00000100000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 10000000000000000002
    // 10000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000102
    // 00000000000000001012
    // Above is the representation of the BitBoard created below in 19x19,
    // the last column (set with `2` in this representation for convenience but actually set to zero)
    // is for endline delimitation.
    let bitboard = BitBoard {
        b: [
            0b10000000000000000000000000000000000000000000000000000000011000000000000000000110000000000000000000000000110000000000000000000100,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000,
            0b00001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000010100000
        ]
    };
    // 11000000000000000002
    // 11000000000000001112
    // 00000000000000001112
    // 00000000000000001112
    // 00011110000000001112
    // 00011110000000000002
    // 00001110000000000002
    // 00001110000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 11000000000000000002
    // 11000000000000000002
    // 11000000000000000002
    // 11000000000000000002
    // 00000000000000000002
    // 00000000000000000112
    // 00000000000000011112
    // 00000000000000011112
    // Above is the representation of the BitBoard created below in 19x19,
    // the last column (set with `2` in this representation for convenience but actually set to zero)
    // is for endline delimitation.
    let expected = BitBoard {
        b: [
            0b11000000000000000000110000000000000011100000000000000000111000000000000000001110000111100000000011100001111000000000000000011110,
            0b00000000000000001110000000000000000000000000000000000000000000000000000000000000000000000000110000000000000000001100000000000000,
            0b00001100000000000000000011000000000000000000000000000000000000000000000000000000111000000000000000011110000000000000000111100000
        ]
    };

    // Act
    let result = bitboard + Direction::All;
    println!("Bitboard:\n{}", bitboard);
    println!("Expected:\n{}", expected);
    println!("Result:\n{}", result);

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_erosion_on_bitboard_north_axis() {
    // Arrange
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000010010010000002
    // 00000001010100000002
    // 00000000111000000002
    // 00000011111110000002
    // 00000000111000000002
    // 00000001010100000002
    // 00000010010010000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // Above is the representation of the BitBoard created below in 19x19,
    // the last column (set with `2` in this representation for convenience but actually set to zero)
    // is for endline delimitation.
    let bitboard = BitBoard {
        b: [
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010,
            0b01001000000000000001010100000000000000001110000000000000001111111000000000000000111000000000000000010101000000000000001001001000,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
        ]
    };
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000010000000002
    // 00000000010000000002
    // 00000000111000000002
    // 00000000111000000002
    // 00000000010000000002
    // 00000000010000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // Above is the representation of the BitBoard created below in 19x19,
    // the last column (set with `2` in this representation for convenience but actually set to zero)
    // is for endline delimitation.
    let expected = BitBoard {
        b: [
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
            0b01000000000000000000010000000000000000001110000000000000000011100000000000000000010000000000000000000100000000000000000000000000,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
        ]
    };

    // Act
    let result = bitboard - Axis::Vertical;
    println!("Bitboard:\n{}", bitboard);
    println!("Expected:\n{}", expected);
    println!("Result:\n{}", result);

    // Assert
    assert_eq!(expected, result);
}
// #endregion Tests Dilation/Erosion

//=========================================
// Tests for method from_string on BitBoard
//=========================================

// #region Tests from_string
#[test]
fn test_from_str_on_bitboard() {
    // Arrange
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000010010010000002
    // 00000001010100000002
    // 00000000111000000002
    // 00000011111110000002
    // 00000000111000000002
    // 00000001010100000002
    // 00000010010010000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // 00000000000000000002
    // Above is the representation of the BitBoard created below in 19x19,
    // the last column (set with `2` in this representation for convenience but actually set to zero)
    // is for endline delimitation.
    let expected = BitBoard {
        b: [
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010,
            0b01001000000000000001010100000000000000001110000000000000001111111000000000000000111000000000000000010101000000000000001001001000,
            0b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
        ]
    };

    // Act
    let result = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000001001001000000
        0000000101010000000
        0000000011100000000
        0000001111111000000
        0000000011100000000
        0000000101010000000
        0000001001001000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");

    // Assert
    println!("Expected:\n{}", expected);
    println!("Result:\n{}", result);
    assert_eq!(expected, result);
}
// #endregion Tests from_string