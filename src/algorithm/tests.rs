use crate::{goban::Goban, node::Node};
use crate::bitboard::BitBoard;
use crate::algorithm::Algorithm;

#[test]
fn test_get_potential_moves_with_one_open_two() {
    // Arrange
    let player = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000001000000
        0000000000000000000
        0000000000100000000
        0000000001000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let opponent = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000010000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let expected = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let mut algo = Algorithm::new();
    algo.update_initial_state(Goban::new(player, opponent), BitBoard::empty(), 0, 0);

    // Act
    let result = algo.get_potential_moves(&algo.initial);
    println!("Here is the result:\n{}", result);

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_get_potential_moves_with_one_unbreakable_five() {
    // Arrange
    let player = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000001010000000
        0000000000000000000
        0000000000000000000
        0000000001000000000
        0000000000100000000
        0000000000010000000
        0000000100000100000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let opponent = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000001000000
        0000000000010000000
        0000001110100000000
        0000000001000000000
        0000000010000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000011011000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let expected = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000100000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000100000000000
        0000000000000000000
        0000000000000000000
        0000000000100000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let mut algo = Algorithm::new();
    algo.update_initial_state(Goban::new(player, opponent), BitBoard::empty(), 0, 0);

    // Act
    let result = algo.get_potential_moves(&algo.initial);
    println!("Here is the result:\n{}", result);

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_get_potential_moves_with_one_breakable_five() {
    // Arrange
    let player = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000100000000000
        0000000001010000000
        0000000000000000000
        0000000000000000000
        0000000001000000000
        0000000000100000000
        0000000000010000000
        0000000100000100000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let opponent = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000001000000
        0000000000010000000
        0000001110100000000
        0000000001000000000
        0000000010000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000011011000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let expected = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000100000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let mut algo = Algorithm::new();
    algo.update_initial_state(Goban::new(player, opponent), BitBoard::empty(), 0, 0);

    // Act
    let result = algo.get_potential_moves(&algo.initial);
    println!("Here is the result:\n{}", result);

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_get_potential_moves_with_multiple_threats_and_one_split_four() {
    // Arrange
    let player = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000001010000000
        0000000000000000000
        0000000000000000000
        0000000001000000000
        0000000000100000000
        0000000000010000000
        0000000100000100000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let opponent = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000001110100000000
        0000000001000000000
        0000000010000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000011011000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let expected = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000100000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let mut algo = Algorithm::new();
    algo.update_initial_state(Goban::new(player, opponent), BitBoard::empty(), 0, 0);

    // Act
    let result = algo.get_potential_moves(&algo.initial);
    println!("Here is the result:\n{}", result);

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_get_potential_moves_with_threat_from_opponent() {
    // Arrange
    let player = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000001000000000
        0000000000100000000
        0000000000010000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let opponent = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000100000000
        0000000001000000000
        0000000010000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let expected = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000010000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000100000000000
        0000000000000000000
        0000000000000000000
        0000000000001000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let mut algo = Algorithm::new();
    algo.update_initial_state(Goban::new(player, opponent), BitBoard::empty(), 0, 0);

    // Act
    let result = algo.get_potential_moves(&algo.initial);
    println!("Here is the result:\n{}", result);

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_get_potential_moves_with_first_turn_completed() {
    // Arrange
    let player = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000001000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let opponent = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000010000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let expected = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000001100000000
        0000000010100000000
        0000000011100000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let mut algo = Algorithm::new();
    algo.update_initial_state(Goban::new(player, opponent), BitBoard::empty(), 0, 0);

    // Act
    let result = algo.get_potential_moves(&algo.initial);
    println!("Here is the result:\n{}", result);

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_get_potential_moves_with_no_move_played() {
    // Arrange
    let player = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let opponent = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let expected = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000001000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let mut algo = Algorithm::new();
    algo.update_initial_state(Goban::new(player, opponent), BitBoard::empty(), 0, 0);

    // Act
    let result = algo.get_potential_moves(&algo.initial);
    println!("Here is the result:\n{}", result);

    // Assert
    assert_eq!(expected, result);
}

#[test]
fn test_get_potential_moves_with_only_one_opponent_move() {
    // Arrange
    let player = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let opponent = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000001000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let expected = BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000011100000000
        0000000010100000000
        0000000011100000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    ");
    let mut algo = Algorithm::new();
    algo.update_initial_state(Goban::new(player, opponent), BitBoard::empty(), 0, 0);

    // Act
    let result = algo.get_potential_moves(&algo.initial);
    println!("Here is the result:\n{}", result);

    // Assert
    assert_eq!(expected, result);
}

#[test]
// This test is quite time-consuming and serves basically no purpose at this point,
// we better not to run it especially using GitHub Actions.
#[ignore]
fn test_algorithm()
{
    let (mut player, mut enemy) = (BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000011000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    "), BitBoard::from_str("
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000010000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
        0000000000000000000
    "));
    let mut next_move = enemy;
    let mut algo = Algorithm::new();
    let mut result_node = Node::default();

    for _ in 0..10 {
        let initial = Goban::new(player, enemy);
        algo.update_initial_state(initial, next_move, result_node.get_player_captures(), result_node.get_opponent_captures());
        let next_move_opt = algo.get_next_move(2);
        if next_move_opt.is_none() { break; }
        result_node = next_move_opt.unwrap();
        next_move = result_node.get_item().get_player() ^ initial.get_player();
        println!("Here is the next move to play for player:\n{}", next_move);
        player |= next_move;
        println!("Player's BitBoard:\n{}", player);
        let initial = Goban::new(enemy, player);
        algo.update_initial_state(initial, next_move, result_node.get_opponent_captures(), result_node.get_player_captures());
        let next_move_opt = algo.get_next_move(2);
        if next_move_opt.is_none() { break; }
        result_node = next_move_opt.unwrap();
        next_move = result_node.get_item().get_player() ^ initial.get_player();
        println!("Here is the next move to play for enemy:\n{}", next_move);
        enemy |= next_move;
        println!("Enemy's BitBoard:\n{}", enemy);
    }
    todo!();
}